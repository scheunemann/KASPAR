/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * KasparBehaviourPanel.java
 *
 * Created on 25-May-2011, 22:21:58
 */
package gui;

import data.Action;
import data.GUIButton;
import data.Robot;
import data.User;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;
import javax.swing.AbstractAction;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.KeyStroke;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import managers.SessionManager;
import runners.ActionRunner;

/**
 *
 * @author Sven
 */
public class BehaviourPanel extends javax.swing.JPanel {

    private User currentUser;
    private Set<User> users;
    private DefaultListModel keymapModel;
    private Robot robot;

    /**
     * Creates new form KasparBehaviourPanel
     */
    public BehaviourPanel(Robot robot) {
        // Initialise

        // Load KeyMaps
        users = new HashSet<User>();
        keymapModel = new DefaultListModel();
        updateKeyMaps();
        if (users.size() > 0) {
            currentUser = users.iterator().next();
        } else {
            currentUser = new User();
        }

        initComponents();

        // Catch list chanegs in sequence list to adjust buttons and to add sequence to table
        lstKeyMaps.addListSelectionListener(new ListSelectionListener() {
            @Override
            public void valueChanged(ListSelectionEvent e) {
                if (lstKeyMaps.getSelectedIndex() != -1) {
                    setKeyMap((User) lstKeyMaps.getSelectedValue());
                }
            }
        });

        populatePanel();
    }

    /**
     * This method is called from within the constructor to initialise the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pnlKeyMaps = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        lstKeyMaps = new javax.swing.JList();
        jScrollPane1 = new javax.swing.JScrollPane();
        pnlButtons = new javax.swing.JPanel();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        pnlMouseMove = new javax.swing.JPanel();

        setName("Control"); // NOI18N

        pnlKeyMaps.setBorder(javax.swing.BorderFactory.createTitledBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true), "Available KeyMaps:"));

        lstKeyMaps.setModel(keymapModel);
        lstKeyMaps.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane3.setViewportView(lstKeyMaps);

        org.jdesktop.layout.GroupLayout pnlKeyMapsLayout = new org.jdesktop.layout.GroupLayout(pnlKeyMaps);
        pnlKeyMaps.setLayout(pnlKeyMapsLayout);
        pnlKeyMapsLayout.setHorizontalGroup(
            pnlKeyMapsLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(pnlKeyMapsLayout.createSequentialGroup()
                .addContainerGap()
                .add(jScrollPane3, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE)
                .addContainerGap())
        );
        pnlKeyMapsLayout.setVerticalGroup(
            pnlKeyMapsLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, pnlKeyMapsLayout.createSequentialGroup()
                .add(jScrollPane3, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 146, Short.MAX_VALUE)
                .addContainerGap())
        );

        jScrollPane1.setBorder(null);

        org.jdesktop.layout.GroupLayout pnlButtonsLayout = new org.jdesktop.layout.GroupLayout(pnlButtons);
        pnlButtons.setLayout(pnlButtonsLayout);
        pnlButtonsLayout.setHorizontalGroup(
            pnlButtonsLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 359, Short.MAX_VALUE)
        );
        pnlButtonsLayout.setVerticalGroup(
            pnlButtonsLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 485, Short.MAX_VALUE)
        );

        jScrollPane1.setViewportView(pnlButtons);

        jTabbedPane1.setMinimumSize(new java.awt.Dimension(200, 200));

        org.jdesktop.layout.GroupLayout pnlMouseMoveLayout = new org.jdesktop.layout.GroupLayout(pnlMouseMove);
        pnlMouseMove.setLayout(pnlMouseMoveLayout);
        pnlMouseMoveLayout.setHorizontalGroup(
            pnlMouseMoveLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 292, Short.MAX_VALUE)
        );
        pnlMouseMoveLayout.setVerticalGroup(
            pnlMouseMoveLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 262, Short.MAX_VALUE)
        );

        jTabbedPane1.addTab("MouseMove", pnlMouseMove);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 349, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                    .add(pnlKeyMaps, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 300, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 487, Short.MAX_VALUE)
                    .add(layout.createSequentialGroup()
                        .add(pnlKeyMaps, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 300, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Update the sequence list and make sure GUI is up to date. Method clears
     * and refills the sequence list model
     */
    public final void updateKeyMaps() {

        keymapModel.clear();
        // make sure sequences are up to date
        loadKeyMaps();
        // Sort sequences
        LinkedList<User> maps = new LinkedList<User>();
        maps.addAll(users);
        Collections.sort(maps);
        // add sequences to table
        for (User s : maps) {
            keymapModel.addElement(s);
        }
    }

    /**
     * Gets the list of sequences saved in KasparSequence. It doesn't force a
     * reload of all sequences but KasparSequence should take care of reloading
     * if needed
     */
    private void loadKeyMaps() {
        users.clear();
        for (User kMap : SessionManager.getCurrentInteraction().getUsers()) {
            users.add(kMap);
        }
    }

    public final void populatePanel() {

        pnlButtons.removeAll();
        pnlButtons.setLayout(new GridLayout((int) Math.ceil(currentUser.getButtons().size() / 2.0), 2, 5, 5));

        this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).clear();
        this.getActionMap().clear();

        // Create buttons for all sequences and add them to the panel
        for (GUIButton seqName : currentUser.getButtons()) {

            Action kSeq = seqName.getSequence();
            this.getActionMap().put(seqName, new keyAction(this.robot, kSeq));

            // Create button for sequence
            JButton btn = new JButton(this.getActionMap().get(kSeq.getName()));
            btn.setText(seqName.getTitle());

            if (ActionRunner.isValid(kSeq)) {
                btn.setEnabled(false);
            }

            // And add to the panel
            pnlButtons.add(btn);
            for (String key : seqName.getHotKeys()) {
                KeyStroke ks;
                if (key.length() == 1) {
                    ks = KeyStroke.getKeyStroke(key.toCharArray()[0]);
                } else {
                    ks = KeyStroke.getKeyStroke(key);
                }

                this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(
                        //TODO: Handle modifiers (ctrl, alt, etc)
                        ks,
                        kSeq);
            }
        }

        pnlButtons.repaint();
        pnlButtons.revalidate();
    }

    /**
     * Make the given key map the currently used key map.
     *
     * @param keyMapName Name of the key map to be set. If name does not appear
     * in list of current key maps a unnamed key map is created and used instead
     */
    private void setKeyMap(User keyMap) {

        if (keyMap != null) {
            currentUser = keyMap;
        } else {
            currentUser = new User();
        }

        populatePanel();
    }

    public void updatePanel() {
        updateKeyMaps();
        currentUser = (User) keymapModel.firstElement();
        populatePanel();
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JList lstKeyMaps;
    private javax.swing.JPanel pnlButtons;
    private javax.swing.JPanel pnlKeyMaps;
    private javax.swing.JPanel pnlMouseMove;
    // End of variables declaration//GEN-END:variables

    private class keyAction extends AbstractAction {

        private Action seq;
        private Robot robot;

        public keyAction(Robot robot, Action seq) {
            this.seq = seq;
            this.robot = robot;
        }

        @Override
        public void actionPerformed(ActionEvent e) {
            new ActionRunner(this.robot).execute(seq);
        }
    }
}
